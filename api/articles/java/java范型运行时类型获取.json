{"title":"java范型运行时类型获取","uid":"693d61e4ffefde59b7a2ab0d6ba29929","slug":"java/java范型运行时类型获取","date":"2022-03-29T09:02:16.000Z","updated":"2022-05-13T15:59:53.302Z","comments":true,"path":"api/articles/java/java范型运行时类型获取.json","keywords":null,"cover":null,"content":"<p>反射是我喜欢喜欢 java 的一个重要原因，它在保证静态语言特性的同时，为你提供了一些动态的特性，你可以通过反射做一些很令人惊奇的事情。本文将通过反射和继承来让你获取泛型的运行时类型。</p>\n<p>java 泛型使用的是 type erasure。它的泛型代码只有一份，泛型实现需要在编译和运行时都进行一定的操作。<br>它的反射机制也为我们获取运行时泛型类型提供了一些接口：<code>java.lang.reflect.TypeVariable</code> 和 <code>java.lang.reflect.ParameterizedType</code>。</p>\n<h1 id=\"1-类型变量的声明\"><a href=\"#1-类型变量的声明\" class=\"headerlink\" title=\"1. 类型变量的声明\"></a>1. 类型变量的声明</h1><p><code>TypeVariable</code>类型变量是各种类型变量的通用超接口，主要保存了类型变量(泛型)的具体声明的信息，比如：类型变量的名称，边界等，但是你无法通过该类来获取具体的运行时类型。<br>它就像是泛型类或者接口的泛型部分的声明而已。而<code>TypeVariable</code>接口只要和另一个接口<code>java.lang.reflect.GenericDeclaration</code>泛型声明紧密关联。</p>\n<h2 id=\"1-1-GenericDeclaration-可以泛型声明的元素\"><a href=\"#1-1-GenericDeclaration-可以泛型声明的元素\" class=\"headerlink\" title=\"1.1 GenericDeclaration 可以泛型声明的元素\"></a>1.1 GenericDeclaration 可以泛型声明的元素</h2><p><code>GenericDeclaration</code>是 Java 反射包中，所有可以声明泛型类型的语法元素的父接口。它只有一个方法：</p>\n<p><code>TypeVariable&lt;?&gt;[] getTypeParameters()</code>;</p>\n<p>这个方法是懒加载泛型声明的所有的类型变量信息。</p>\n<p>该接口有三个实现：<code>java.lang.Class</code>、<code>java.lang.reflect.Constructor</code>和<code>java.lang.reflect.Method</code>，也就是说我们可以在类、构造函数、方法上使用泛型变量。<br>通过调用对应反射的 <code>#getTypeParameters()</code> 方法就可以得到具体的泛型声明信息。</p>\n<h2 id=\"1-2-TypeVariable-泛型声明\"><a href=\"#1-2-TypeVariable-泛型声明\" class=\"headerlink\" title=\"1.2 TypeVariable 泛型声明\"></a>1.2 TypeVariable 泛型声明</h2><p>接下来让我们看看泛型声明具体都包含了什么信息：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TypeVariable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">D</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">GenericDeclaration</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Type</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">AnnotatedElement</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token class-name\">Type</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getBounds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">D</span> <span class=\"token function\">getGenericDeclaration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">AnnotatedType</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getAnnotatedBounds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>首先该接口是个泛型接口，里面包含了刚刚的 <code>GenericDeclaration</code> ，即它的信息中包含了具体泛型申明的位置：方法、构造函数还是普通函数，这个信息可以通过 <code>#getGenericDeclaration()</code> 方法获取到。</p>\n<p>另外 <code>#getBounds()</code> 可以获取泛型的上限边界信息，<code>#getName()</code> 可以获取泛型声明时的名称，比如我们常用的 <code>&lt;T&gt;</code> 这个 T。</p>\n<h1 id=\"2-运行时类型的获取\"><a href=\"#2-运行时类型的获取\" class=\"headerlink\" title=\"2. 运行时类型的获取\"></a>2. 运行时类型的获取</h1><p>关于运行时类型的获取我们首先要知道一个接口：<code>java.lang.reflect.ParameterizedType</code> 所有泛型运行时的类或者接口都会实现这个接口，将具体的参数类型信息保存在实现中。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ParameterizedType</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Type</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token class-name\">Type</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getActualTypeArguments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Type</span> <span class=\"token function\">getRawType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Type</span> <span class=\"token function\">getOwnerType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里我们就主要关注 <code>getActualTypeArguments()</code> 方法，这个方法就是所有的子类具体泛型参数类型的列表，这个长度和 <code>TypeVariable</code> 中的泛型参数声明列表应该是一样大小的。</p>\n<p>java 的泛型是通过 type erasure 实现的，所以普通的静态泛型方法是不能获取到泛型类型的，它在运行时使用的是 cast 来帮助方法的执行。</p>\n<p>因为在反射机制中提供了关于继承&#x2F;实现泛型基类&#x2F;接口的具体细节，这些细节可以通过 <code>Class#getGenericInfo()</code>获取，注意这是在子&#x2F;实现类中保存的，我们可以通过 Class 类中的两个具体方法来获取具体的运行时类型：<code>Class&lt;?&gt;#getGenericSuperclass()</code> 获取所有的超类类型；<code>Class&lt;?&gt;#getGenericInterfaces()</code> 获取所有的接口类型。这两个方法可以得到当前类的所有直接超类和接口，然后遍历这些类或者接口如果是 <code>ParameterizedType</code> 类型的，就可以将其转换为 <code>ParameterizedType</code> 然后获取具体的泛型参数类型了。</p>\n<p>一定要注意，普通的静态方法是不能获取到具体的参数类型的，因为它在字节码阶段全部都被编译成 java.lang.Object 在运行阶段通过 cast 才转换成你想要的具体类型。</p>\n","text":"反射是我喜欢喜欢 java 的一个重要原因，它在保证静态语言特性的同时，为你提供了一些动态的特性，你可以通过反射做一些很令人惊奇的事情。本文将通过反射和继承来让你获取泛型的运行时类型。 java 泛型使用的是 type erasure。它的泛型代码只有一份，泛型实现需要在编译和运...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"},{"name":"反射","slug":"反射","count":1,"path":"api/tags/反射.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">1. 类型变量的声明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-GenericDeclaration-%E5%8F%AF%E4%BB%A5%E6%B3%9B%E5%9E%8B%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">1.1 GenericDeclaration 可以泛型声明的元素</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-TypeVariable-%E6%B3%9B%E5%9E%8B%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">1.2 TypeVariable 泛型声明</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">2. 运行时类型的获取</span></a></li></ol>","author":{"name":"Wttch","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Always trust your spirit.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"wordpress+docker+nginx安装wordpress","uid":"9cc0e1afa72b6df8eaf80b1eb99225e3","slug":"wordpress-docker-nginx安装wordpress","date":"2022-03-31T02:18:49.000Z","updated":"2022-05-13T15:59:53.307Z","comments":true,"path":"api/articles/wordpress-docker-nginx安装wordpress.json","keywords":null,"cover":null,"text":"之前使用nginx + wordpress搭建过wordpress博客，但是整个过程过于复杂和繁琐，最近开发项目中使用到了docker和docker-compose感觉到项目自动部署和配置的便捷，这次我们选用 docker 和 wordpress 来进行 wordpress 的部...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Wttch","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Always trust your spirit.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}