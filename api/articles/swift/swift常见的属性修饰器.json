{"title":"swift常见的属性修饰器","uid":"dc21f442b71df5b05ff757451695e8d1","slug":"swift/swift常见的属性修饰器","date":"2022-04-07T03:25:50.000Z","updated":"2022-05-13T15:59:53.306Z","comments":true,"path":"api/articles/swift/swift常见的属性修饰器.json","keywords":null,"cover":null,"content":"<h1 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"@Environment\"></a>@Environment</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>使用<code>@EnvironmentObject</code>可以监听到自定义的model；<br>但是如果是系统的一些内置的类呢，则可以使用<code>@Environment</code>监听；</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token attribute atrule\">@Environment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">\\</span><span class=\"token punctuation\">.</span>editMode<span class=\"token punctuation\">)</span> <span class=\"token keyword\">var</span> editMode<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"Binding\"><a href=\"#Binding\" class=\"headerlink\" title=\"@Binding\"></a>@Binding</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>双向绑定，用于父子视图的双向传递。修改子视图的Binding值，会触发父视图的State改变重新渲染body。修改父视图的State的值同样也会重新通过Binding传递给子视图，触发重新渲染body。</p>\n<h2 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token attribute atrule\">@Binding</span> <span class=\"token keyword\">var</span> value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"@State\"></a>@State</h1><h2 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>通过使用 @State 修饰器我们可以关联出 View 的状态. SwiftUI 将会把使用过 @State 修饰器的属性存储到一个特殊的内存区域，并且这个区域和 View struct 是隔离的. 当 @State 装饰过的属性发生了变化，SwiftUI 会根据新的属性值重新创建视图</p>\n<h2 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token attribute atrule\">@State</span> <span class=\"token keyword\">var</span> value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"Published-ObservedObject\"><a href=\"#Published-ObservedObject\" class=\"headerlink\" title=\"@Published + @ObservedObject\"></a>@Published + @ObservedObject</h1><h2 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>@Published是SwiftUI最有用的包装之一，允许我们创建出能够被自动观察的对象属性，SwiftUI会自动监视这个属性，一旦发生了改变，会自动修改与该属性绑定的界面。</p>\n<p>比如我们定义的数据结构Model，前提是 @Published 要在 ObservableObject 下使用<br>然后用 @ObservedObject 来引用这个对象，当然@State 不会报错，但是无法更新</p>\n<h2 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ModelData</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">ObservableObject</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token attribute atrule\">@Published</span> <span class=\"token keyword\">var</span> name<span class=\"token punctuation\">:</span><span class=\"token class-name\">String</span> <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"\"</span></span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">ContentView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">View</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token attribute atrule\">@ObservedObject</span> <span class=\"token keyword\">var</span> model<span class=\"token punctuation\">:</span><span class=\"token class-name\">ModelData</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">ModelData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"@Environment简介使用@EnvironmentObject可以监听到自定义的model；但是如果是系统的一些内置的类呢，则可以使用@Environment监听； 示例@Environment(\\.editMode) var editMode @Binding简介双向绑定...","link":"","photos":[],"count_time":{"symbolsCount":847,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"swift","slug":"swift","count":1,"path":"api/tags/swift.json"},{"name":"属性修饰器","slug":"属性修饰器","count":1,"path":"api/tags/属性修饰器.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Environment\"><span class=\"toc-text\">@Environment</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Binding\"><span class=\"toc-text\">@Binding</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B-1\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#State\"><span class=\"toc-text\">@State</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B-2\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Published-ObservedObject\"><span class=\"toc-text\">@Published + @ObservedObject</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B-3\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-3\"><span class=\"toc-text\">示例</span></a></li></ol></li></ol>","author":{"name":"Wttch","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Always trust your spirit.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"软件公司可重用库的建设","uid":"2a123aa39ec1f5ddc61848229772e97d","slug":"架构/软件公司可重用库的建设","date":"2022-04-07T09:40:35.000Z","updated":"2022-05-13T15:59:53.308Z","comments":true,"path":"api/articles/架构/软件公司可重用库的建设.json","keywords":null,"cover":null,"text":" 很早之前看到的很有感悟的一片文章，备份一下，防丢。原文地址 这个想法由来已久，也是因为自己在现在效力的公司中能看到一些不良的现象，但自己却不是管理层，没有任何的执行力去改变它。 软件公司管理职位越往上，越不熟悉技术方面，加上此举和重构一样，很可能是吃力不讨好的做法，要得到执行则...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"架构","slug":"架构","count":1,"path":"api/tags/架构.json"},{"name":"转载","slug":"转载","count":1,"path":"api/tags/转载.json"}],"author":{"name":"Wttch","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Always trust your spirit.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"gradle小记","uid":"406fe1c4291c9a9fa691dc5fa45f97fd","slug":"构建工具/gradle小记","date":"2022-03-31T06:26:13.000Z","updated":"2022-05-13T15:59:53.307Z","comments":true,"path":"api/articles/构建工具/gradle小记.json","keywords":null,"cover":null,"text":"环境变量要想通过 System.getProperties()或者环境变量在 gradle 中获取相关的值，需要在指定环境变量的时候在环境变量的key前加上前缀。 通过 System.getProperties() 获取需要添加前缀 org.gradle.project.;通过环...","link":"","photos":[],"count_time":{"symbolsCount":172,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"gradle","slug":"gradle","count":1,"path":"api/tags/gradle.json"}],"author":{"name":"Wttch","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Always trust your spirit.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}