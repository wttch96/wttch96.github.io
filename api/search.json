[{"id":"2fbfd2ddc5541e970a83e54c13dd8052","title":"swiftUI多窗口","content":"找了好久终于找到一个优雅的方式打开多个窗口。\n窗口声明，窗体id，传递的参数类型，后面闭包使用传递的参数生成窗体。\n// A window group that displays messages.\n// 接收 Message 类型的窗口参数\nWindowGroup(id: \"test\", for: Message.self) &#123; $messageID in\n    MessageDetail(messageID: messageID)\n&#125;\n\n打开窗口并传递参数，使用 Environment 获取 openWindow，使用 id 和具体的消息对象即可。\nvar message: Message\n@Environment(\\.openWindow) private var openWindow\n\nvar body: some View &#123;\n    Button(\"Open message\") &#123;\n        openWindow(id: \"test\", value: message.id)\n    &#125;\n&#125;","slug":"swift/swiftUI多窗口","date":"2023-09-05T08:34:01.000Z","categories_index":"","tags_index":"","author_index":"Wttch"},{"id":"91e0a4a93e4ee6f9ef1f4f9607c79a1f","title":"深入理解java虚拟机（二）","content":"二、垃圾收集器与内存分配策略\n\n\n\n\n\n\n\n\nJvm启动GC日志：-Xloggc:/your/log/path/gc.log，笔者测试使用的是JDK17，启动时会提示参数过时：-Xloggc is deprecated. Will use -Xlog:gc:/your/log/path/gc.log instead.\n2.1 对象已死？2.1.1 引用计数算法在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n在Java领域，主流的虚拟机没有选用引用计数算法来管理内存的，很难解决对象之间相互循环引用的问题。\n2.1.2 可达性分析算法当前主流的商用程序语言（Java、C#等）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。将“GC Roots”作为根对象，如果对象到根对象之间没有“引用链”（Reference Chain），也就是从GC Roots到对象不可达，则证明此对象不再被使用。\n\n\n在Java技术体系里，固定可作为GC Roots的对象包括以下几种：\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象，比如：各个线程被调用方法堆栈中使用的参数、局部变量、临时变量等；\n在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量；\n在方法区中常量引用的对象，比如字符串常量池（String Table）里的引用；\n在本地方法栈中JNI（Native方法）引用的对象；\nJVM内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（NPE，OOM）等，还有系统类加载器；\n所有被同步锁（synchronized 关键字）持有的对象；\n反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n\n\n\n\n\n\n\n\n\n\nJMXBean；\nJVMTI简介。\n\n除了这些固定的集合外，根据用户使用的垃圾收集器和当前回收的内存区域不同，还有一些对象可以“临时”加入，比如分代收集和局部回收（Partial GC）要考虑到不同代或者其他区域时候存在对象的引用，需要把这些有关联的区域都一起加入到GC Roots集合中。\n","slug":"java/jvm/深入理解java虚拟机/深入理解java虚拟机（二）","date":"2022-05-13T13:09:44.000Z","categories_index":"jvm","tags_index":"java,jvm,笔记","author_index":"Wttch"},{"id":"15c9c1ab2fcef5aa3d42081d95493338","title":"深入理解java虚拟机（一）","content":"一、Java 内存区域与内存溢出异常1.1 运行时数据区域java虚拟机在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域各有各自的用途，以及创建时间和销毁时间，有的区域随着虚拟机的进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，java虚拟机的内存将会包括几个运行时数据区域：\n\n\n1.1.1 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间，可以当作程序执行的行号指示器。它用来控制程序的分支、循环、跳转、异常处理、线程恢复等基础功能。\n因为每个线程都是独立执行的，为了能够在切换线程后能恢复到正确的执行位置，每个线程都需要有独立的程序计数器，独立存储互不影响，这类内存区域称为“线程私有”内存。\n如果正在执行Java方法，则记录正在执行的虚拟机字节码指令的地址，如果正在执行本地方法，这个计数器则应为空(Underfined)。此区域是《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n1.1.2 Java虚拟机栈与程序计数器一样，虚拟机栈(Java Virtual Machine Stack)也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法的调用到结束，就对应栈帧在虚拟机栈中入栈和出栈的过程。\n我们常关注的内存区域的“堆”和“栈”中“栈”，通常就是虚拟机栈，实际上应该指的是虚拟机栈中的局部变量表部分。\n局部变量表存放了Java虚拟机基本的数据类型（原始数据类型）、对象引用（类引用、数组引用、接口引用）和returnAddress类型（指向一条字节码指令的地址，returnAddress类型与Java编程语言类型没有直接关联）。\n这些数据类型在局部变量表中都以局部变量槽（Solt）来表示，其中long、double都会占用两个槽，其余的数据类型只有一个。具体的大小还要和虚拟机的具体实现相关，如果一个槽可能占32个比特、64个比特。\n《Java虚拟机规范》中，虚拟机栈中规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError（最常见的就是循环调用）；如果虚拟机栈容量可以动态扩展（和虚拟机的实现有关，Classic虚拟机允许扩展，HotSpot是不允许的，所以只要申请栈空间成功了就不会出现OOM，如果申请失败会出现OOM），当栈扩展时无法申请到足够的内存则会跑出OutOfMemoryError。\n1.1.3 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈的作用非常相似，一个是为执行Java方法服务，一个是为执行本地方法服务。《Java虚拟机规范》中对其没有做强制规定（Hotspot甚至把它合二为一），两者都会抛出StackOverflowError和OOM。\n1.1.4 Java堆Java堆是垃圾收集器管理的内存区域，因此也被称为“GC堆”。此内存区域的唯一目的就是存放对象实例，Java世界“几乎”所有的对象实例都在这里分配内存。垃圾收集器大部分都是基于分代收集设计的，所以Java堆中经常会出现“新生代”、“老年代”、“永久代”、“Eden空间”、“From Survivor空间”、“To Survivor空间”名词。\n从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。\nJava堆既可以被实现成固定大小，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果Java堆中没有内存完成实例分配，并且堆也无法扩展时，就会抛出OOM异常。\n1.1.5 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等区域。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但它却有一个别名叫做“非堆”（Non-Heap），目的是为了和Java堆区分开来。\n方法区和永生代不是等价的，具体的虚拟机的实现是不同的。《Java虚拟机规范》对方法区的约束是非常宽松的，甚至可以不实现垃圾收集。并不是进入方法区就如同永生代的名字一样“永久”存在，这区域的回收目标主要是对常量池的回收和对类型的卸载。如果方法区无法满足新的内存分配需求时，将抛出OOM异常。\n1.1.6 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用来存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n运行时常量池对于Class文件常量池的另外一个重要的特征就是具有动态性，有些特性可以在运行时将常量放入池中，比如String#intern()方法。\n运行时常量池在无法申请到内存的时候也会抛出OOM异常。\n1.1.7 直接内存（堆外内存）Java应用程序通过直接方法（Unsafe类、本地方法等）申请的内存，这部分内存不会受到Java堆大小的限制，当内存超过物理内存限制的时候也会导致出现OOM异常。\n1.2 HotSpot虚拟机对象探秘1.2.1 对象的创建语言层面上可以简单通过new、clone、反射、反序列化等方式创建一个对象。\nHotSpot虚拟机对象创建过程如下图所示：\n\n\n\n指针碰撞（Bump The Pointer）：假设内存规整，使用的内存和空闲的内存各放一边，中间放一个指针来作为分界，分配内存就是将指针向空闲空间移动一个和对象大小相等的距离；\n空闲列表（Free List）：使用的内存和空闲内存交错，虚拟机维护一个列表，记录可用的内存，然后从列表中寻找一块足够大的内存；\n\n一般内存是否规整又由所采用的垃圾收集器是否带有空间压缩功能（Compact）能力决定。因此当使用Serial、ParNew等压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，简单而高效；当使用CMS这种基于清除（Sweep）算法的收集器时，理论上只能采用复杂的空间列表来分配。\n另一个要考虑的问题就是并发，怎么保证多个线程同时分配内存的情况。解决这个问题有两个可选方案：\n\n对分配内存进行同步——实际上采用CAS配上失败重试的方法保证更新操作的原子性；\n每个线程在Java堆中预先分配一小块内存：本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），只有本地缓冲区用完了才会需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来决定。\n\n初始化零值，如果使用TLAB的话，这项工作可以提现到TLAB分配时顺便进行。\n设置对象头信息，例如这是哪个类的实例、如何找到类的元数据信息、对象的哈希码（实际是调用Object#hashCode()时才会计算）、对象的GC分代年龄、是否启用偏向锁等信息。\n到这时，从虚拟机视角一个对象已经产生了，从Java程序视角来看，对象创建才刚刚开始——构造函数（()方法还没有执行），所有的字段都为默认的零值，其他资源和状态也没有初始化。一般来说new指令后接着执行()方法，这样在Java视角里对象才会被创建。\n1.2.2 对象内存布局HotSpot虚拟机中，对象在内存中的存储布局分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n\n\n对象头一般包含两类信息：\n\nMark Word：存储对象自身运行时数据，如哈希码、GC分代年龄、所状态标志、线程持有的锁、偏向线程ID、偏向时间戳等（大小和虚拟机位数相关）；\nKlass Pointer：对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；如果对象是Java数组，还有一块记录数组长度的数据，虚拟机可以确定普通对象的大小，但是数组长度不确定，就无法算出数组的实际大小；为了节约内存可以使用选项 -XX:+UseCompressedOops 开启指针压缩，其中 oop即ordinary object pointer 普通对象指针；\n\n实例数据部分才是真正存储的有效信息，即我们定义的各种类型的字段内容，无论是父类继承还是子类的字段。字段顺序会受HotSpot虚拟机分配策略参数-XX:FieldsAllocationStyle和字段在Java源码中的定义顺序影响。如果HotSpot虚拟机参数+XX:CompactFields为true（默认为true），子类的字段可以插在父类的空隙中，以节省空间。\n对象填充就是占位符的作用，HotSpot虚拟机要求对象起始地址都是8字节的整倍数。所以就需要填充来对齐。\n1.2.3 对象的访问定位对象的访问方式由虚拟机实现而定，主流的访问方式有使用句柄和直接访问指针两种：\n\n句柄访问：Java堆中分出一块内存作为句柄池，reference中存储对象句柄地址，句柄包含了对象实例数据和类型数据各自的地址；\n直接指针访问：Java堆中对象的内存中就放入对象类型数据，reference就是对象地址；\n\n\n\n\n\n直接使用指针最大的好处就是速度快，HotSpot主要使用直接指针方式进行访问（如果使用了Shenandoah收集器，会有一次额外转发）。\n1.3 OOM异常1.3.1 Java堆溢出堆最小值参数-Xms和最大值-Xmx设置成一样可以避免自动扩展，通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现OOM的时候自动Dump内存堆转储快照。\n/**\n * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n *\n * @author wttch\n */\npublic class Demo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        var list = new LinkedList&lt;>();\n        while (true) &#123;\n            list.add(new Demo());\n        &#125;\n    &#125;\n&#125;\n\n\n\n\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid58590.hprof ...\nHeap dump file created [37138671 bytes in 0.091 secs]\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n\tat Demo.main(Demo.java:16)\n\n使用工具（如Eclipse Memory Analyzer，Idea也可以直接打开.hprof文件）分析，先确认是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。\n\n\n内存泄漏：查看内存泄漏对象的GC Roots引用链，找到内存泄漏对象的引用路径，从而找出为什么无法回收它们。\n不是内存泄漏：看那些对象是必须存活的，调整参数或者检查让生命周期过长的对象设计是否合理。\n1.3.2 虚拟机栈和本地方法栈溢出HotSpot虚拟机并不区分虚拟机栈和本地方法栈，对HotSpot来说-Xoss参数（设置本地方法栈大小）虽然存在但没有任何效果，栈容量只能由-Xss参数来设定。\n《Java虚拟机规范》在此处定义了两种异常：\n\n如果线程请求的栈深度大雨虚拟机所允许的最大深度，将会抛出StackOverflowError；\n如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OOM；\n\nHotSpot虚拟机是不支持栈的动态扩展的，所以只会因为栈容量无法容纳新的栈帧而抛出StackOverflowError。\n\n/**\n * JVM args: -Xss1m\n *\n * @author wttch\n */\npublic class JvmStackSOF &#123;\n    private int stackLength = 1;\n\n    public void stackLeak() &#123;\n        stackLength++;\n        stackLeak();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        JvmStackSOF stackSOF = new JvmStackSOF();\n        try &#123;\n            stackSOF.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(\"Stack Length:\" + stackSOF.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\n\n异常信息：\n&gt; Task :JvmStackSOF.main() FAILED\nStack Length:14807\nException in thread &quot;main&quot; java.lang.StackOverflowError\n\n缩减栈内存容量（注意⚠️：虚拟机会有一个最小栈内存限制，小于该限制值虚拟机将无法启动）：\nJVM args: -Xss500k\n\n异常信息：\n&gt; Task :JvmStackSOF.main() FAILED\nStack Length:4296\nException in thread &quot;main&quot; java.lang.StackOverflowError\n\n添加大量本地变量：\n/**\n * JVM args: -Xss1m\n *\n * @author wttch\n */\npublic class JvmStackSOF &#123;\n    private int stackLength = 1;\n\n    public void stackLeak() &#123;\n        long a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;\n        a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 = a10 = 1L;\n        stackLength++;\n        stackLeak();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        JvmStackSOF stackSOF = new JvmStackSOF();\n        try &#123;\n            stackSOF.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(\"Stack Length:\" + stackSOF.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\n异常信息：\n&gt; Task :JvmStackSOF.main() FAILED\nStack Length:8940\nException in thread &quot;main&quot; java.lang.StackOverflowError\n\n\n\n\n使用-Xss参数减少栈内存容量，抛出StackOverflowError，异常出现时输出的堆栈深度也会相应地减小；\n定义大量本地变量，增大此方法的本地变量表的长度，抛出异常时堆栈的深度也会相应的减少；\n\n1.3.3 方法区和运行时常量池溢出JDK8以后，运行时常量池是在堆内的，通过使用-Xmx参数限制对内存，产生运行时常量池的溢出。\n/**\n * JVM args: -Xmx3m\n *\n * @author wttch\n */\npublic class RuntimeConstantPoolOOM &#123;\n    public static void main(String[] args) &#123;\n        var set = new HashSet&lt;String>();\n\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            set.add(String.format(\"运行时常量：%d\", i).intern());\n        &#125;\n    &#125;\n&#125;\n\n异常信息：\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n\tat java.base&#x2F;java.util.Formatter.format(Formatter.java:2689)\n\tat java.base&#x2F;java.util.Formatter.format(Formatter.java:2625)\n\tat java.base&#x2F;java.lang.String.format(String.java:4140)\n\tat com.wttch.demo.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:15)\n\n方法区溢出不是特别好操作，在JDK8之前可以通过CGLib生成大量的动态类，JDK8之后“永生代”被“元空间”代替后方法区就更难迫使虚拟机产生方法区的溢出异常了。\nHotSpot提供了一些“元空间”的防御措施：\n\n-XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说受限于本地内存大小；\n-XX:MetaspaceSize：元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集器进行类型卸载，同时收集器会对该值进行调整：如果释放了大量空间，就是适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize适当提高该值；\n-XX:MinMetaspaceFreeRatio：在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少元空间不足导致的垃圾收集的频率。-XX:MaxMetaSpaceFreeRatio相反的功能。\n\n1.3.4 本地内存溢出直接内存导致的溢出，一般Heap Dump文件中不会看到有什么明显的异常信息，如果溢出后Dump文件很小，就有可能是直接内存溢出了。\n","slug":"java/jvm/深入理解java虚拟机/深入理解java虚拟机（一）","date":"2022-05-13T02:54:44.000Z","categories_index":"","tags_index":"java,jvm,笔记","author_index":"Wttch"},{"id":"26f3911f90f70b197f9664f32065b4d3","title":"系统的捡一下Mysql","content":"\n\n\n\n\n\n\n\n\n使用mysql很久了，但没有系统的学习过mysql，看看漏掉了那些基础但又有用东西。\n一、Mysql基础使用1.1 Mysql命令1. 命令结束符号一个命令要想执行必须使用;、\\g、\\G这几个符号之一作为结尾。\n符号\\g等同于;，是我们常用的命令结束语句。\\G可以将数据表格转换为横向，即第一列为字段名，然后数据依次在后面的列，对字段很多的时候的查询展示很有帮助。\n2. 可以一次提交多个命令例如：三个语句同时混合上边的命令结束符号\nmysql&gt; select now(); select now()\\g select now()\\G\n+---------------------+\n| now()               |\n+---------------------+\n| 2022-05-12 11:34:49 |\n+---------------------+\n1 row in set (0.000 sec)\n\n+---------------------+\n| now()               |\n+---------------------+\n| 2022-05-12 11:34:49 |\n+---------------------+\n1 row in set (0.000 sec)\n\n*************************** 1. row ***************************\nnow(): 2022-05-12 11:34:49\n1 row in set (0.000 sec)\n\n3. 使用\\c放弃本次操作可以使用如果你想放弃本次编写的命令，可以在输入的命令后边加上\\c，比如这样：\nmysql&gt; SELECT NOW()\\c\nmysql&gt;\n\n如果不使用\\c，那客户端会以为这是一个多行命令，还在一直傻傻的等你输入命令～\n二、MySQL数据类型2.1 MySQL整型类型\n\n\n类型\n占用的存储空间（单位：字节）\n无符号数取值范围\n有符号数取值范围\n\n\n\nTINYINT\n1\n$0\\sim 2^8-1$\n$-2^7\\sim 2^7-1$\n\n\nSMALLINT\n2\n$0\\sim 2^{16}-1$\n$-2^{15}\\sim -2^{15}-1$\n\n\nMEDIUMINT\n3\n$0\\sim 2^{24}-1$\n$-2^{23}\\sim 2^{23}-1$\n\n\nINT&#x2F;INTEGER\n4\n$0 \\sim 2^{32} - 1$\n$-2^{31} \\sim 2^{31}-1$\n\n\nBIGINT\n8\n$0 \\sim 2^{64} - 1$\n$-2^{63} \\sim 2^{63} - 1$\n\n\n2.2 MySQL浮点型类型\n\n\n类型\n占用的存储空间（单位：字节）\n绝对值最小非0值\n绝对值最大非0值\n\n\n\nFLOAT\n4\n±1.175494351E-38\n±3.402823466E+38\n\n\nDOUBLE\n8\n±2.2250738585072014E-308\n±1.7976931348623157E+308\n\n\n2.3 设置最大位数和小数位数\n&#96;&#96;&#96;sql\nFLOAT(M, D)\nDOUBLE(M, D)\n\n可以用来限制存储到本列中的小数范围。其中\n\nM表示该小数最多需要的十进制有效数字个数\nD表示该小数的小数点后的十进制数字的个数。\n\n2.4 定点数类型类型DECIMAL(M, D),占用的存储空间取决于M和D，取值范围也取决于M和D。\n2.5 日期和时间类型\n\n\n类型\n存储空间要求\n取值范围\n含义\n\n\n\nYEAR\n1字节\n$1901\\sim 2155$\n年份值\n\n\nDATE\n3字节\n$’1000-01-01’\\sim ‘9999-12-31’$\n日期值\n\n\nTIME\n3字节+小数秒的存储空间\n$’-838:59:59[.000000]’ \\sim ‘838:59:59[.000000]’$\n时间值\n\n\nDATETIME\n5字节+小数秒的存储空间\n$’1000-01-01 00:00:00[.000000]’ ～ ‘9999-12-31 23:59:59[.999999]’$\n日期加时间值\n\n\nTIMESTAMP\n4字节+小数秒的存储空间\n$’1970-01-01 00:00:01[.000000]’ ～ ‘2038-01-19 03:14:07[.999999]’$\n时间戳\n\n\n小数秒的存储空间：\n\n\n\n保留的小数秒位数\n额外需要的存储空间\n\n\n\n0\n0字节\n\n\n1&#x2F;2\n1字节\n\n\n3&#x2F;4\n2字节\n\n\n5&#x2F;6\n3字节\n\n\n2.5 MySQL的字符串类型\n\n\n类型\n最大长度\n存储空间要求\n备注\n\n\n\nCHAR(M)\nM个字符\nM*W个字节\nM取值范围0 ~ 255，默认为1CHAR和CHAR(1)同义，CHAR(0)只能存储&#39;&#39;或者NULL；CHAR会对剩余的空间补空格字符补齐\n\n\nVARCHAR(M)\nM个字符\nL+1或L+2个字节\nM理论取值范围0 ~ 65535，但MySQL规定，表中某一行包含的所有列的数据大小总共不得超过65535字节，所以VARCHAR(M)字符数量是小于65535的\n\n\nTINYTEXT\n$2^8-1$个字节\nL+1个字节\n不受65535限制\n\n\nTEXT\n$2^{16} - 1$字节\nL+2个字节\n不受65535限制\n\n\nMEDIUMTEXT\n$2^{24} - 1$个字节\nL+3个字节\n不受65535限制\n\n\nLONGTEXT\n$2^{32} - 1$个字节\nL+4个字节\n不受65535限制\n\n\n其中M代表该数据类型最多能存储的字符数量，L代表我们实际向该类型的属性中存储的字符串在特定字符集下所占的字节数，W代表在该特定字符集下，编码一个字符最多需要的字节数（ascii取1，gbk取2，utf8取3等）。\n2.6 ENUM类型和SET类型ENUM('str1', 'str2', 'str3')\nSET('str1', 'str2', 'str3')\n\n2.7 二进制类型\nBIT(M)\nBINARY(M)&#x2F;VARBINARY(M)\nTINYBLOB\nBLOB\nMEDIUMBLOB\nLONGBLOB\n\n三、存储函数3.1 创建存储函数CREATE FUNCTION 存储函数名称([参数列表])\nRETURNS 返回值类型\nBEGIN\n    函数体内容\nEND\n\n例如（要先用delimiter修改语句结束分割符号）：\nmysql> delimiter $\nmysql> CREATE FUNCTION avg_score(s VARCHAR(100))\n    -> RETURNS DOUBLE\n    -> BEGIN\n    ->     RETURN (SELECT AVG(score) FROM student_score WHERE subject = s);\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\n\n3.2 查看和删除存储函数查看存储函数：\nSHOW FUNCTION STATUS [LIKE 需要匹配的函数名]\n\n查看函数定义：\nSHOW CREATE FUNCTION 函数名\n\n自定义变量：\nSET @value = 1;\n\n3.3 判断语句的编写IF 表达式 THEN\n    处理语句列表\n[ELSEIF 表达式 THEN\n    处理语句列表]\n... # 这里可以有多个ELSEIF语句\n[ELSE\n    处理语句列表]\nEND IF;\n\n3.4 循环语句的编写WHILE循环语句WHILE 表达式 DO\n    处理语句列表\nEND WHILE;\n\nREPEAT循环语句REPEAT\n    处理语句列表\nUNTIL 表达式 END REPEAT;\n\nLOOP循环语句LOOP\n    处理语句列表\nEND LOOP;\n\n四、存储过程4.1 创建存储过程CREATE PROCEDURE 存储过程名称([参数列表])\nBEGIN\n    需要执行的语句\nEND\n\n例如：\nmysql> delimiter $\nmysql> CREATE PROCEDURE t1_operation(\n    ->     m1_value INT,\n    ->     n1_value CHAR(1)\n    -> )\n    -> BEGIN\n    ->     SELECT * FROM t1;\n    ->     INSERT INTO t1(m1, n1) VALUES(m1_value, n1_value);\n    ->     SELECT * FROM t1;\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\nmysql>\n\n4.2 存储过程的调用CALL 存储过程([参数列表]);\n\n4.3 查看和删除存储过程查看当前数据库中创建的存储过程都有哪些的语句：\nSHOW PROCEDURE STATUS [LIKE 需要匹配的存储过程名称]\n\n查看某个存储过程具体是怎么定义的语句：\nSHOW CREATE PROCEDURE 存储过程名称\n\n删除存储过程的语句：\nDROP PROCEDURE 存储过程名称\n\n4.4 存储过程参数前缀前缀IN，OUT，INOUT\n五、游标的使用5.1 创建游标DECLARE 游标名称 CURSOR FOR 查询语句;\n\n5.2 打开和关闭游标在创建完游标之后，我们需要手动打开和关闭游标，语法也简单：\nOPEN 游标名称;\n\nCLOSE 游标名称;\n\n5.3 使用游标获取记录FETCH 游标名 INTO 变量1, 变量2, ... 变量n\n\n每调用一次 FETCH 语句，游标就移动到下一条记录的位置。\n六、触发器和事件6.1 触发器我们使用MySQL的过程中可能会有下边这些需求：\n\n在向t1表插入或更新数据之前对自动对数据进行校验，要求m1列的值必须在1~10之间，校验规则如下：\n如果插入的记录的m1列的值小于1，则按1插入。\n如果m1列的值大于10，则按10插入。\n\n\n在向t1表中插入记录之后自动把这条记录插入到t2表。\n\n也就是我们在对表中的记录做增、删、改操作前和后都可能需要让MySQL服务器自动执行一些额外的语句，这个就是所谓的触发器的应用场景。\n6.1.1 创建触发器CREATE TRIGGER 触发器名\n&#123;BEFORE|AFTER&#125;\n&#123;INSERT|DELETE|UPDATE&#125;\nON 表名\nFOR EACH ROW\nBEGIN\n    触发器内容\nEND\n\n6.1.2 查看和删除触发器查看当前数据库中定义的所有触发器的语句：\nSHOW TRIGGERS;\n\n查看某个具体的触发器的定义：\nSHOW CREATE TRIGGER 触发器名;\n\n删除触发器：\nDROP TRIGGER 触发器名;\n\n6.2 事件有时候我们想让MySQL服务器在某个时间点或者每隔一段时间自动地执行一些语句，这时候就需要去创建一个事件。\n6.2.1 创建事件CREATE EVENT 事件名\nON SCHEDULE\n&#123;\n    AT 某个确定的时间点| \n    EVERY 期望的时间间隔 [STARTS datetime][END datetime]\n&#125;\nDO\nBEGIN\n    具体的语句\nEND\n\n事件支持两种类型的自动执行方式：\n\n在某个确定的时间点执行：\n比如：\nCREATE EVENT insert_t1_event\nON SCHEDULE\nAT '2019-09-04 15:48:54'\nDO\nBEGIN\n    INSERT INTO t1(m1, n1) VALUES(6, 'f');\nEND\n\n每隔一段时间执行一次\n比如：\nCREATE EVENT insert_t1\nON SCHEDULE\nEVERY 1 HOUR\nDO\nBEGIN\n    INSERT INTO t1(m1, n1) VALUES(6, 'f');\nEND\n\n6.2.2 查看和删除事件查看当前数据库中定义的所有事件的语句：\nSHOW EVENTS;\n\n查看某个具体的事件的定义：\nSHOW CREATE EVENT 事件名;\n\n删除事件：\nDROP EVENT 事件名;\n\n6.2.3 事件使用注意事项默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们使用下边的语句手动开启该功能：\nmysql> SET GLOBAL event_scheduler = ON;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql>\n\n\n\n\n\n\n\n\n\n\n小贴士： event_scheduler其实是一个系统变量，它的值也可以在MySQL服务器启动的时候通过启动参数或者通过配置文件来设置event_scheduler的值。这些所谓的系统变量、启动参数、配置文件的各种东东并不是我们小白现在需要掌握的，大家忽略它们就好了～\n","slug":"mysql/系统的捡一下Mysql","date":"2022-05-11T09:57:01.000Z","categories_index":"","tags_index":"mysql","author_index":"Wttch"},{"id":"2a123aa39ec1f5ddc61848229772e97d","title":"软件公司可重用库的建设","content":"\n\n\n\n\n\n\n\n\n很早之前看到的很有感悟的一片文章，备份一下，防丢。原文地址\n 这个想法由来已久，也是因为自己在现在效力的公司中能看到一些不良的现象，但自己却不是管理层，没有任何的执行力去改变它。  \n 软件公司管理职位越往上，越不熟悉技术方面，加上此举和重构一样，很可能是吃力不讨好的做法，要得到执行则是想当困难的。客户没有这些要求，我们为什么要去做呢？如果员工有这个念头，我基本上可以看出他对自己的公司是没有想法的，工作如快餐式开发，做完拉倒的迹象很明显。  \n 软件公司越往大规模发展就越要注意可重用代码的利用，最好就是建立自己的代码库。  \n 我在公司做了一阵子开发后发现，开发团队中根本没有这个意识。当然开发团队没这个意识不是团队的错，而是带团队的人的错误。就是上层管理不重视，所以下层也就不重视了。为什么说团队中没有可重用代码的意识呢？很显然，公司没有建立自己的可重用代码库，员工在开发时也没有这个意识，当碰到问题不会先去问一下公司里是不是已经写过类似的算法了，这导致信息的极度不共享。员工可能会在不同的项目中反反复复地写那些简单的小函数。稍微能有点意识的人可能自己会把代码收集起来，自己用时拷贝粘贴即可。但是个人的东西一般是不会拿出来秀的，所以团队的水平仍然是大众的平均水平。个别案例，甚至为了一个简单的函数而研究很多工时，那可真是让人哭笑不得了。而且研究的时候，管理层还不一定知道他把时间全花在了那个小函数上，而是以为开发确实可能需要那些时间。这一定层次上也影响到管理层的管理和进度把握。 那么我们怎么去组建公司自己的可重用代码库呢？  \n一、做好精神领袖。有想法是好事，但一定要去做，不做的想法再好也没有用。我们首先就要给员工灌输这个意识，不仅仅是程序员，做设计的、搞测试的也要有这个意识。在工作中随时寻找可以抽象成复用的那一部分。要把这种意识从新人培训开始，就要深入的植入。此外也要培养员工对公司的家庭归属感。  \n二、建立专门组织和电子化管理员工有了意识，那么接下来，我觉得公司应该有专门的人员管理这个库，建立起相关的组织来维护它。对外可以采用接口的形式，即一般不提供源码，只提供访问接口和库。  \n首先要建立一个查询系统，提供库内已收入的方法，函数等等详细信息的查询，这个查询可以不设权限，和项目有关的人员都能自由使用。这一步很重要，因为写程序的人大多不善交际，如果你说谁有好的方法要抽象出来的，和项目经理反应，我估计就没人出来反应，这样这个想法就得不到很好的互动了。  \n三、惰性增量式与后台研发式创建库 对于小公司可能没有太多人力资源，很多重要的东西只能在实战中积累，那么就是所谓的惰性增量式。即遇到一个问题实现一个问题，最后入库，不做单独的可重用库开发。有实力的公司可以同时由专人来负责其它可能的需求（当前并没有遇到），把它开发成重用库即为研发式创建。  \n四、制定重用的准则。首先关于什么代码应该重用？一方面是通用的，每个产品都能用到的代码，肯定要入库；另一方面是具有专业性的算法，比如图形算法等等，这种代码的通用性仅限于那个领域，不是所有产品都能用上的，但也要建立，因为他的技术含量高，避免二次反复开发。  \n对于客户而言，我们是一家人，是软件的开发和提供方，所以公司的代码一般不分服务与客户，代码大家都能看到，如果任其自由复制修改应用，那么虽然也叫重用但没办法统一，也就无法管理了。所以我主张，公司的重用库一般情况下最好实现封装，普通项目开发人员一般也得不到它的代码。他们要做的就是上报可重用的代码、查询库中已有的代码、直接调用。即使测试过程中发现是重用库的Bug，也和开发人员没有关系，由管理重用代码库的组织来解决，找到代码的作者，由其修改，新库一发布，就行了。所以说公司内部建立这种请求－－服务的关系的话，各自的职责便明确化了。  \n开发人员一般比较偷懒，有了请求－－服务的模式后，请求的人就会增多，这对于加深开发人员可重用意识也很有积极的意义。一般我们也懒得去动脑筋写算法，有这个查询机会何乐而不为呢？系统上一查，没有，于是可以请求。可重用管理组的人在评定通过后，可以由他们来开发把这个算法添加到库中，我们在得到信息后可以直接调用。重用管理组背后的技术支持可能是牛人们，这有什么问题呢，我们是要开发产品，不是去比试哪个大学毕业生牛，大家各自有各自位置！有现成的就可以复用，有更强大的开发技术资源的就可以用，不要什么东西都自己去做。这一点很重要。  \n当然，如果开发组的需求不是很通用，和库中的接口不协调的话，也可以变通，可以向管理组请求提供库的代码，在代码的基础上修改后直接应用，这样一来这些代码就不应该算是调用重用库了，一般是不推荐这样做的。或者项目组可以考虑应用适配器模式，适配接口，尽量用上库。实在需要改代码内部算法的也就只能提供源码让其修改后使用，总之尽量不要重新开发。  \n另外，如果开发人员上报的可重用代码抽象地不理想，换言之，抽象地不通用，那么管理组应该要与项目组协调，必须把接口设计成通用性高的，由项目这边妥协修改调用形式；当然，如果因某些原因（比如接口是客户规定的），无法修改的，就不要收入库中了（可以收入改正后的版本单独入库），因为很明显这段代码是为了项目而生存的，没必要重用化。  \n五、维护。这个就不用多说了，既然决定一试，就不是创建出来后可以袖手不管。诸如库的更新升级或者修改Bug的事务可能也不会很轻松，但是不能因此而荒废。可重用库的价值很大程度上就要看维护了。  \n修改库的Bug原则上谁写谁改，如果是开发人员提供的，应该由开发人员修正，管理组审核。  \n再一个就是文档，文档一定要详细，一定要实时更新。程序即时编辑提示文档、外部API手册、不同的版本、函数的不同用法、使用场合等等一定要详细，说白了，内部算法就算是爱因斯坦再世写的，放出的接口和文档，也要让傻瓜用的起来。我非常注重这点，因为我也有和这类开发人员合作过，算法的调用相当复杂（就是要你调用的人也要懂这个懂那个，否则用不来）。这个我很奇怪，但也怪不着他们，因为他们自己懂就以会天下人都懂，而没有这方面的意识了。哪天，微软和你说想用Windows？把这个二极管焊在主板的X位置，把那个三极管焊在Y位置，不要焊反，否则电脑烧了，你就别用Windows了。反正我们提供你Windows了，是你不会用，和我们无关。技术人员是有牛人，但人外有人，对于用Windows再牛的程序员，微软如果这样做，他也牛不起来了，除非去用Linux。所以做技术的一定要考虑怎样让不懂技术的人用得爽，这绝对是一个功力。诚然，他们的解释是合情合理的：算法就应该是纯净的，任何与算法无关的事前准备之类的，不属于算法内部。解释得很好，我也赞成，那么请麻烦一下，算法都写出来了，你就再写个适配接口吧，就把这部分当成应用，而不是你的算法不就行了吗。  \n六、单元测试这是极其重要的一环，如果有专职的维护和技术人员的话，一定要建立对已有库的单元测试用例和相关测试程序。Bug修正后，首先要做的是，把原测试用例测试通过，保证修正后不破坏其它功能。然后新添加测试用例测试。  \n 可重用库，必须以严谨的方式管理，否则基础的东西出了问题，上层的构建将会直接面临崩溃的风险。千万不要等新库一发布，客户的新系统，老程序，产品A，产品B都崩溃了。 以上谈了些个人对公司建设可重用代码库的一些想法，最后总结一下好处和风险：  \n **好处：  \n\n这是公司的无形资产，是公司的发展日志。员工是公司的，员工创造的思想也是公司的，既然是公司的，公司不去注意收集、管理这些无形的东西，将来造成技术流失，能怪谁呢（只见管理层抱着一堆产品的源码，感叹地说，我们是有技术的，全在这里面，但是却没人用的起来）？  \n降低以后的项目开发难度和缩短开发速度，提高软件质量。  \n对公司的产品的架构形式统一管理。也就是说这些可重用的代码不要嵌在各个软件产品中，而是独立成通用的包或库。需要时只要对外发布更新库而不用更新客户程序。  \n可重用代码库相当于公司的笔记，公司不怕核心员工跳槽，因为他曾努力写下的算法以经整理成可重用的库了。注意，一定要整理成规范易用的接口（算法再复杂也不要影响使用者的使用心态），不整理的随心所欲的源代码禁止入库。  \n加强团队成员间的交流与和作。因为加强了这方面的意识，开发人员随时会注意这些问题而与周边组员，甚至重用库的管理人员进行沟通。\n\n **风险：  \n\n具有高风险，执行前需要一个深远的考虑和计划。否则不易执行及运行长久。  \n维护库需要花费不少时间和精力，否则一旦发布新库，很有可能，所有产品受影响。不过可以考虑只针对部分产品发布库。但是如果你能确定现有库有一个Bug，而目前所有产品都使用这个库，那么从职业道德上来说，应该通知所有产品更新库，而不能等到客户Bug再现后再做处理。或者我们可以在公司网站上发布库，让客户自由决定是否下载最新的库。  \n正因为这些库是基础的基础，所以在评定审查以及讨论良好通用的接口是十分重要的，一旦决定将无法随意变更，公司要有这个实力安排这些专业人员，从而增加了成本。只有做好了，才能收回成本，应用于以后的所有开发，做不好就真的是吃力不讨好了。  \n产品系列具有严重依赖于这些库的特性，所以没有很好的管理，一旦出问题往往不是一个产品出事情，所有产品都会出问题。如果公司没有这种管理能力付不起这种风险，宁可一个产品一个产品分开开发，也不愿做一劳永逸的事，请不要使用这个方案。  \n这个风险是采用这个方案的一个很大风险。就是人力资源上容易出问题。大学刚毕业的有些人还是很有牛劲的，总希望做些厉害的开发，如果他总是用公司的基础库，甚至代码都看不到，对他来说可能会不爽，觉得学不到东西，造成人才流失。这个只有进行教育了，实际上，在业务逻辑上也是很有用武之地的，不可能练不到人，或者往设计方向走，怎么可能练不到人，不要一味追求写底层的东西，公司能提供给你也是开发人员的福气啊，要学会站在巨人的肩膀上。所以一定要让开发人员理解公司的这种做法。\n\n说到这里，我又在想自己现在效力的公司，完全不注重“整理”。可重用库的建设我们就不去谈了，这种花成本没收益的事公司决计不做，那也应该注意下最简单的代码整理吧，至少在开发一个很有难度的项目时，管理层不懂得整理资源。以至于其它组开发类似的东西时，往往会听到管理层说这样的话，“好像某某在N年前做过这个东西，去问问他吧！”然后就看到开发人员从一个部跑到另一个部去取经。就算别人N年前做过，别人可不是闲人啊，专门给你解决这问题吗。就算愿意，他自己估计也忘了差不多了吧，还得再重新捡起来。对两个部来说都是降低效率的做法。如果别人已经离职了呢？那就把当年的项目源码翻出来吧，一起啃一起学，先把项目理解了，再找到你要的东西。于是加班开始了，公司还振振有辞，说加班是没有办法的，竞争激烈啊。要知道，良好的管理是不会加班的，加班绝对是哪个环节出问题了。  \n自己亲自体会，越发觉得建立可重用库的重要性。不是说公司没有重用的思想，而是觉得不到位。公司的重用思想，就是粘贴拷贝，修修补补，完全没有管理。如果把重用意识上升到管理层次，那么对公司的将来，至少在技术上，我是非常有信心的。\n","slug":"架构/软件公司可重用库的建设","date":"2022-04-07T09:40:35.000Z","categories_index":"","tags_index":"架构,转载","author_index":"Wttch"},{"id":"dc21f442b71df5b05ff757451695e8d1","title":"swift常见的属性修饰器","content":"@Environment简介使用@EnvironmentObject可以监听到自定义的model；但是如果是系统的一些内置的类呢，则可以使用@Environment监听；\n示例@Environment(\\.editMode) var editMode\n\n@Binding简介双向绑定，用于父子视图的双向传递。修改子视图的Binding值，会触发父视图的State改变重新渲染body。修改父视图的State的值同样也会重新通过Binding传递给子视图，触发重新渲染body。\n示例@Binding var value: Int\n\n@State简介通过使用 @State 修饰器我们可以关联出 View 的状态. SwiftUI 将会把使用过 @State 修饰器的属性存储到一个特殊的内存区域，并且这个区域和 View struct 是隔离的. 当 @State 装饰过的属性发生了变化，SwiftUI 会根据新的属性值重新创建视图\n示例@State var value: Bool = false\n\n@Published + @ObservedObject简介@Published是SwiftUI最有用的包装之一，允许我们创建出能够被自动观察的对象属性，SwiftUI会自动监视这个属性，一旦发生了改变，会自动修改与该属性绑定的界面。\n比如我们定义的数据结构Model，前提是 @Published 要在 ObservableObject 下使用然后用 @ObservedObject 来引用这个对象，当然@State 不会报错，但是无法更新\n示例class ModelData: ObservableObject&#123;\n  @Published var name:String = \"\"\n&#125;\n\nstruct ContentView: View&#123;\n  @ObservedObject var model:ModelData = ModelData()\n&#125;","slug":"swift/swift常见的属性修饰器","date":"2022-04-07T03:25:50.000Z","categories_index":"","tags_index":"swift,属性修饰器","author_index":"Wttch"},{"id":"406fe1c4291c9a9fa691dc5fa45f97fd","title":"gradle小记","content":"环境变量要想通过 System.getProperties()或者环境变量在 gradle 中获取相关的值，需要在指定环境变量的时候在环境变量的key前加上前缀。\n通过 System.getProperties() 获取需要添加前缀 org.gradle.project.;通过环境变量获取要添加前缀 ORG_GRADLE_PROJECT_。\n","slug":"构建工具/gradle小记","date":"2022-03-31T06:26:13.000Z","categories_index":"","tags_index":"gradle","author_index":"Wttch"},{"id":"63d2f7b33d78f0291d5339de6a110a5c","title":"Mysql四种隔离级别","content":"一、事务的基本要素（ACID）\n原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。\n一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。\n隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。\n持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n\n二、事务的并发问题\n脏读： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。\n不可重复读： 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\n幻读： 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n\n小结： 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。\n\n三、Mysql 的事务隔离级别\n\n\n事务隔离级别\n脏读\n不可重复读\n幻读\n\n\n\n读未提交（read-uncommitted）\n√\n√\n√\n\n\n不可重复读（read-committed）\n×\n√\n√\n\n\n可重复读（repeatable-read）\n×\n×\n√\n\n\n串行化（serializable）\n×\n×\n×\n\n\n补充：\n\n事务隔离级别为读提交时，写数据只会锁住相应的行。\n事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。\n事务隔离级别为串行化时，读写数据都会锁住整张表。\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。\nMYSQL MVCC实现机制参考链接：https://blog.csdn.net/whoamiyang/article/details/51901888 。\n关于next-key 锁可以参考链接：https://blog.csdn.net/bigtree_3721/article/details/73731377 。\n\n","slug":"Mysql四种隔离级别","date":"2022-03-31T06:15:50.000Z","categories_index":"","tags_index":"mysql","author_index":"Wttch"},{"id":"245d80e5558082de7c26fdd85370c466","title":"kotlin高阶函数","content":"\n\n\n\n\n\n\n\n\n高阶函数 run, with, apply, also, let, takeIf, takeUnless, repeat\n高阶函数 T.() -&gt; R 和 (T) -&gt; R在泛型中经常会出现T.() -&gt; R和(T) -&gt; R类型的回调函数, 他们的区别在于: T.() -&gt; R\n可以在回调函数中使用this来指代回调函数的传参T, 而(T) -&gt; R使用的是 it来指代.\n具体调用如下\nT.()\n\n(T) it\n\n(T) this\n\nrun 执行回调函数并返回执行结果@kotlin.internal.InlineOnly\npublic inline fun &lt;R> run(block: () -> R): R &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return block()\n&#125;\n\n@kotlin.internal.InlineOnly\npublic inline fun &lt;T, R> T.run(block: T.() -> R): R &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return block()\n&#125;\n\nwith 传入对象并返回对象指定函数的执行结果@kotlin.internal.InlineOnly\npublic inline fun &lt;T, R> with(receiver: T, block: T.() -> R): R &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return receiver.block()\n&#125;\n\napply 执行回调函数并返回对象自身@kotlin.internal.InlineOnly\npublic inline fun &lt;T> T.apply(block: T.() -> Unit): T &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    block()\n    return this\n&#125;\n\nalso 将自身对象传入回调函数执行并返回自身对象@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun &lt;T> T.also(block: (T) -> Unit): T &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    block(this)\n    return this\n&#125;\n\nlet 将自身对象传入回调函数执行并返回执行结果@kotlin.internal.InlineOnly\npublic inline fun &lt;T, R> T.let(block: (T) -> R): R &#123;\n    contract &#123;\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return block(this)\n&#125;\n\ntakeIf 如果将自身对象执行断言方法, 如果断言为真返回自身否则返回 null@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun &lt;T> T.takeIf(predicate: (T) -> Boolean): T? &#123;\n    contract &#123;\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return if (predicate(this)) this else null\n&#125;\n\ntakeUnless 如果将自身对象执行断言方法, 如果断言为假返回自身否则返回 null@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun &lt;T> T.takeUnless(predicate: (T) -> Boolean): T? &#123;\n    contract &#123;\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    &#125;\n    return if (!predicate(this)) this else null\n&#125;\n\nrepeat 执行指定次数的回调函数@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) &#123;\n    contract &#123; callsInPlace(action) &#125;\n\n    for (index in 0 until times) &#123;\n        action(index)\n    &#125;\n&#125;","slug":"java/kotlin/kotlin高阶函数","date":"2022-03-31T02:22:22.000Z","categories_index":"","tags_index":"kotlin","author_index":"Wttch"},{"id":"9cc0e1afa72b6df8eaf80b1eb99225e3","title":"wordpress+docker+nginx安装wordpress","content":"之前使用nginx + wordpress搭建过wordpress博客，但是整个过程过于复杂和繁琐，最近开发项目中使用到了docker和docker-compose感觉到项目自动部署和配置的便捷，这次我们选用 docker 和 wordpress 来进行 wordpress 的部署。nginx 作为外围网关，当然你也可以将 nginx 放入 docker 中。\n1. docker 和 docker-compose 安装首先我们准备好 docker 和 docker-compose，docker 直接使用官方的安装脚本进行安装。安装命令如下：curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n你也可以使用国内一键安装的脚本：curl -sSL https://get.daoclound.io/docker | sh\nLinux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases。\n运行以下命令以下载 Docker Compose 的当前稳定版本：sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n要安装其他版本的 Compose，请替换 1.24.1。\n将可执行权限应用于二进制文件：sudo chmod +x /usr/local/bin/docker-compose\n创建软链：sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n2. docker-compose.yml 文件的编写在 docker 中启动 mysql 和 wordpress 两个容器，将 mysql 和 wordpress 的数据挂载在宿主机中方便将来做数据的迁移。具体的配置文件如下：\nversion: \"3\"\n\nservices:\n  mysql-wordpress:\n    image: mysql:8.0\n    container_name: wordpress-mysql\n    volumes:\n      # mysql 文件夹挂载\n      - ./data/mysql-wordpress:/var/lib/mysql\n    restart: always\n    environment:\n      # 默认密码配置，后面 wordpress 容器要使用到\n      MYSQL_ROOT_PASSWORD: wordpress\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wordpress\n      MYSQL_PASSWORD: wordpress\n\n  wordpress:\n    depends_on:\n      - mysql-wordpress\n    image: wordpress:latest\n    container_name: wordpress\n    volumes:\n       # wordpress 文件挂载\n       - ./data/wordpres:/var/www/html\n    ports:\n      - \"8000:80\"\n    restart: always\n    environment:\n      # wordpress 数据库连接\n      WORDPRESS_DB_HOST: mysql-wordpress:3306\n      WORDPRESS_DB_USER: wordpress\n      WORDPRESS_DB_PASSWORD: wordprses\n      WORDPRESS_DB_NAME: wordpress\n3. 宿主机 nginx 配置首先将 nginx 配置使用 http 访问 wordpress，将 wordpress 初始化。\nupstream wordpress &#123;\n  server localhost:8000;\n&#125;\n\nserver &#123;\n  listen 80;\n  server_name blog.wttch.com;\n\n  location / &#123;\n    proxy_pass http://wordpress;\n    proxy_redirect off;\n\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-Host $host;\n    proxy_set_header X-Forwarded-Server $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    # 转发host信息\n    proxy_set_header Host $host;\n  &#125;\n&#125;\n此时就可以通过 http://blog.wttch.com 访问 wordpress 了。\n附加. 配置 https通过 https://github.com/acmesh-official/acme.sh 你可以配置 https 证书的自动配置，然后将生成的证书配置到 nginx 中。在此之前要记得将 wordpress 的 site_url 和 home 连接修改为 https，不然后面会出现 mixed content 错误。\nnginx https 的具体配置如下：\nupstream wordpress &#123;\n  server localhost:8000;\n&#125;\n\nserver &#123;\n  listen 80;\n  server_name blog.wttch.com;\n\n  rewrite ^&#x2F;(.*?)$ https:&#x2F;&#x2F;blog.wttch.com&#x2F;$1 permanent;\n&#125;\n\nserver &#123;\n  listen 443 ssl;\n  server_name blog.wttch.com;\n\n  location &#x2F; &#123;\n    proxy_pass http:&#x2F;&#x2F;wordpress;\n    proxy_redirect off;\n\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-Host $host;\n    proxy_set_header X-Forwarded-Server $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    # 转发host信息\n    proxy_set_header Host $host;\n  &#125;\n  # ssl证书地址\n  ssl_certificate     &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;cert.pem;  # pem文件的路径\n  ssl_certificate_key  &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;key.pem;  # key文件的路径\n\n  # ssl验证相关配置\n  ssl_session_timeout  5m;    #缓存有效期\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议\n  ssl_prefer_server_ciphers on;   #使用服务器端的首选算法\n&#125;","slug":"wordpress-docker-nginx安装wordpress","date":"2022-03-31T02:18:49.000Z","categories_index":"","tags_index":"","author_index":"Wttch"},{"id":"693d61e4ffefde59b7a2ab0d6ba29929","title":"java范型运行时类型获取","content":"反射是我喜欢喜欢 java 的一个重要原因，它在保证静态语言特性的同时，为你提供了一些动态的特性，你可以通过反射做一些很令人惊奇的事情。本文将通过反射和继承来让你获取泛型的运行时类型。\njava 泛型使用的是 type erasure。它的泛型代码只有一份，泛型实现需要在编译和运行时都进行一定的操作。它的反射机制也为我们获取运行时泛型类型提供了一些接口：java.lang.reflect.TypeVariable 和 java.lang.reflect.ParameterizedType。\n1. 类型变量的声明TypeVariable类型变量是各种类型变量的通用超接口，主要保存了类型变量(泛型)的具体声明的信息，比如：类型变量的名称，边界等，但是你无法通过该类来获取具体的运行时类型。它就像是泛型类或者接口的泛型部分的声明而已。而TypeVariable接口只要和另一个接口java.lang.reflect.GenericDeclaration泛型声明紧密关联。\n1.1 GenericDeclaration 可以泛型声明的元素GenericDeclaration是 Java 反射包中，所有可以声明泛型类型的语法元素的父接口。它只有一个方法：\nTypeVariable&lt;?&gt;[] getTypeParameters();\n这个方法是懒加载泛型声明的所有的类型变量信息。\n该接口有三个实现：java.lang.Class、java.lang.reflect.Constructor和java.lang.reflect.Method，也就是说我们可以在类、构造函数、方法上使用泛型变量。通过调用对应反射的 #getTypeParameters() 方法就可以得到具体的泛型声明信息。\n1.2 TypeVariable 泛型声明接下来让我们看看泛型声明具体都包含了什么信息：\npublic interface TypeVariable&lt;D extends GenericDeclaration> extends Type, AnnotatedElement &#123;\n  Type[] getBounds();\n  D getGenericDeclaration();\n  String getName();\n  AnnotatedType[] getAnnotatedBounds();\n&#125;\n\n首先该接口是个泛型接口，里面包含了刚刚的 GenericDeclaration ，即它的信息中包含了具体泛型申明的位置：方法、构造函数还是普通函数，这个信息可以通过 #getGenericDeclaration() 方法获取到。\n另外 #getBounds() 可以获取泛型的上限边界信息，#getName() 可以获取泛型声明时的名称，比如我们常用的 &lt;T&gt; 这个 T。\n2. 运行时类型的获取关于运行时类型的获取我们首先要知道一个接口：java.lang.reflect.ParameterizedType 所有泛型运行时的类或者接口都会实现这个接口，将具体的参数类型信息保存在实现中。\npublic interface ParameterizedType extends Type &#123; \n  Type[] getActualTypeArguments();\n  Type getRawType();\n  Type getOwnerType();\n&#125;\n这里我们就主要关注 getActualTypeArguments() 方法，这个方法就是所有的子类具体泛型参数类型的列表，这个长度和 TypeVariable 中的泛型参数声明列表应该是一样大小的。\njava 的泛型是通过 type erasure 实现的，所以普通的静态泛型方法是不能获取到泛型类型的，它在运行时使用的是 cast 来帮助方法的执行。\n因为在反射机制中提供了关于继承&#x2F;实现泛型基类&#x2F;接口的具体细节，这些细节可以通过 Class#getGenericInfo()获取，注意这是在子&#x2F;实现类中保存的，我们可以通过 Class 类中的两个具体方法来获取具体的运行时类型：Class&lt;?&gt;#getGenericSuperclass() 获取所有的超类类型；Class&lt;?&gt;#getGenericInterfaces() 获取所有的接口类型。这两个方法可以得到当前类的所有直接超类和接口，然后遍历这些类或者接口如果是 ParameterizedType 类型的，就可以将其转换为 ParameterizedType 然后获取具体的泛型参数类型了。\n一定要注意，普通的静态方法是不能获取到具体的参数类型的，因为它在字节码阶段全部都被编译成 java.lang.Object 在运行阶段通过 cast 才转换成你想要的具体类型。\n","slug":"java/java范型运行时类型获取","date":"2022-03-29T09:02:16.000Z","categories_index":"","tags_index":"java,反射","author_index":"Wttch"},{"id":"d519cd57597a334eb5607f36f217ba8b","title":"修改mac启动台程序图标大小","content":"\n\n\n\n\n\n\n\n\nmac启动台图标大小没法直接调整，我们可以通过修改每行图标的个数来调整图标大小。\n1、调整每一列显示图标数量defaults write com.apple.dock springboard-rows -int 10\n\n2、调整多少行显示图标数量defaults write com.apple.dock springboard-rows -int 8\n3、重置Launchpaddefaults write com.apple.dock ResetLaunchPad -bool TRUE  \n4、重启Dockkillall Dock\n5、恢复默认\ndefaults write com.apple.dock springboard-rows Default\ndefaults write com.apple.dock springboard-columns Default\ndefaults write com.apple.dock ResetLaunchPad -bool TRUE  \nkillall Dock","slug":"修改mac启动台程序图标大小","date":"2022-03-29T08:54:01.000Z","categories_index":"","tags_index":"macOS","author_index":"Wttch"}]